# 基于 Caffeine 实现 JCache（JSR-107）详细设计方案

> 目标：在不侵入 Caffeine 内核的前提下，完整实现 JCache 语义，并保证并发安全、语义一致与可测试性。

---

## 0. 设计范围与约束（必须遵循）

**范围**
- 完整实现 JCache（JSR-107）语义与 API。
- 语义适配层负责过期、事件、统计、EntryProcessor 原子语义等。

**明确约束**
- 不支持注解（移除 @CacheResult 等）。
- 不使用显式锁，仅使用 Caffeine `asMap` 的原子操作。
- 过期清理采用惰性策略（访问/写入/迭代触发），不启后台清理线程。
- 过期清理计入 eviction。
- getAll/removeAll/putAll 等批量操作整体不原子，但单 key 必须原子。
- 必须支持 read-through。
- 必须支持 write-through，失败统一抛出异常并提供失败明细。
- 不需要 invoke 死锁检测。
- 不需要 Spring 集成。
- 不提供外部自定义 Copier 扩展。
- 增加 `YmsConfiguration extends MutableConfiguration`，允许 maximumWeight。
- 开发阶段必须采用 TDD。

---

## 1. 设计目标

1. 严格遵循 JCache 规范语义。
2. 最大化复用 Caffeine 高性能并发结构。
3. 适配层语义清晰、可验证、可维护。
4. 无显式锁的单 key 原子一致性。

---

## 2. 总体架构

```
┌─────────────────────────────┐
│         JCache API 层        │
│ Cache / EntryProcessor / ... │
└─────────────▲───────────────┘
              │ 语义适配
┌─────────────┴───────────────┐
│        语义适配层             │
│ 过期 / 事件 / 统计 / invoke   │
└─────────────▲───────────────┘
              │ 存储与驱逐
┌─────────────┴───────────────┐
│        Caffeine Cache        │
│ 高性能并发 Map / 驱逐策略     │
└─────────────────────────────┘
```

**核心原则**：Caffeine 负责“存与快”，适配层负责“语义与正确”。

---

## 3. 数据模型与 By-Value 语义

### 3.1 Entry 包装模型
```
Expirable<V>
 ├─ value        实际值（已 copy）
 └─ expireTime   绝对过期时间（long）
```

### 3.2 By-Value 规则
- 默认 store-by-value。
- `storeByValue=false` 时使用 identity copy。
- Copier 不对外开放，仅内部封装（序列化 copy / identity）。

### 3.3 Expirable GC 优化（建议）
- **避免不必要的对象创建**：过期时间未变化时复用原对象，不创建新 `Expirable`。
- **Eternal 复用**：对永不过期条目使用共享的 `expireTime=Long.MAX_VALUE` 语义，避免频繁分配。
- **ZERO 语义不驻留**：`Duration.ZERO` 逻辑不可见，避免将其作为可见条目长期驻留。
- **事件解耦**：事件中使用已复制的值，避免 listener 长期持有内部对象。

---

## 4. 并发与原子性模型（无锁）

### 4.0 顶级风险（设计阶段定死）

**风险主题：JCache 原子语义 vs Caffeine `asMap()` 的“假原子性”**

JCache 要求的原子性是 **单 key 的 Cache 语义原子**，不是 Map 视角的线性一致。Caffeine 的 `compute/computeIfAbsent/merge` 仅保证 Map 视角的原子性。

**必须明确原子边界：**
- **原子范围仅限 key → value 的状态转换**（包含过期判断与新值决策）。
- **不包含任何副作用**（I/O、listener 事件、统计累计、read/write-through）。

**强制约束（必须写进实现准则）：**
- `compute` 内只做“状态判断 + 值决策”。
- `loader / writer / event / stats` **全部在 `compute` 之外执行**。
- 任何需要外部 I/O 或可见副作用的操作不得进入 `compute`。

### 4.1 单 key 原子策略
- 使用 `asMap()` 原子操作（`compute/computeIfPresent/putIfAbsent/remove`）。
- 禁止 check-then-act 造成竞态。
- **原子函数内只允许：过期校验 + 新值决策 + 状态转换。**

### 4.2 invoke（EntryProcessor）
- 使用 `asMap().compute(key, ...)` 实现单 key 原子。
- `MutableEntry` 为逻辑态，`get/set/remove` 延迟提交。
- **compute 内仅做状态转换；事件/统计/loader/writer 必须在 compute 之后执行。**
- **read-through 支持**：在 `MutableEntry.getValue()` 触发 read-through 时仍需遵循“副作用不在 compute 内”的约束。

**实现策略（两阶段）：**
1. 第一次 compute：仅判定是否需要 read-through（例如 entry 缺失或过期），并记录“需要加载”的标记。
2. compute 外执行 load。
3. 第二次 compute：携带 load 结果执行 EntryProcessor，并完成状态转换。

**并发丢弃策略：**
- 若第二次 compute 发现值已被其他线程更新：
  - 使用当前缓存新值（非 load 结果）作为 processor 输入。
  - 可选记录 loadDiscarded 计数用于监控。

### 4.3 EntryProcessor 再入与副作用禁止

**规范约束：**JSR-107 不保证 reentrant safety。

**强制规则：**
- **禁止在 EntryProcessor 内调用任何 cache API**（如 `get/put/remove/invoke/getAll` 等）。
- **禁止在 EntryProcessor 内触发 loader / writer / listener**。

**处理策略（二选一，必须固定）：**
1. **检测并抛异常**（推荐）：一旦检测到 reentrant 调用，直接抛出 `CacheException`。
2. **明示不支持并快速失败**：记录错误并抛出 `UnsupportedOperationException`。

---

## 5. 过期与驱逐语义（惰性清理）

### 5.1 过期策略
- `ExpiryPolicy`：
  - `null`：不修改过期时间
  - `Duration.ZERO`：立即过期（逻辑不可见，物理清理由惰性策略完成）
  - `Duration.ETERNAL`：永不过期

### 5.2 惰性清理
- 无后台清理线程。
- 触发路径：`get/getAll/containsKey/iterator/invoke/compute`。
- 写入路径：`put/replace/remove` 先校验过期。
- **风险提示：**长期不访问会导致过期条目驻留，需通过业务访问或运维触发清理来缓解。

### 5.3 过期驱逐计数
- 过期条目移除必须计入 eviction。
- 触发 EXPIRED 事件。

---

## 6. 事件模型

- 事件类型：CREATED / UPDATED / REMOVED / EXPIRED。
- 事件顺序严格遵循规范。
- old/new 值必须为 by-value 结果。

### 6.2 EventPolicy 默认策略（必须固定）

- **默认同步派发**：在调用线程内执行 listener。
- **线程模型**：不创建额外线程；如需异步由业务层封装适配。
- **listener 异常策略**：捕获并记录，**不影响**缓存主流程；异常不回滚状态变更。

### 6.3 EventPolicy 异步方案（可选扩展）

**目标**：在不改变语义顺序的前提下，将事件派发从主路径剥离。

**策略要点：**
- **派发方式**：将事件放入队列，由独立执行器异步消费。
- **顺序保证**：同一 key 的事件必须保持顺序；跨 key 不保证顺序。
- **背压策略**：队列满时可丢弃并记录，或回退为同步派发（需固定一种策略）。
- **异常处理**：listener 异常被捕获并记录，不影响主流程；异步失败不回滚缓存状态。
- **关闭语义**：`close` 时必须 flush 队列或安全丢弃，并记录未派发事件数量。

### 6.1 RemovalCause → JCache Event 映射（必须固定）

| Caffeine RemovalCause | JCache Event | 说明 |
| --- | --- | --- |
| EXPIRED | EXPIRED | 过期移除，事件为 EXPIRED |
| SIZE / WEIGHT | （不触发事件） | 容量/权重驱逐仅计 eviction |
| EXPLICIT | REMOVED | 显式删除（remove/removeAll） |
| REPLACED | UPDATED | 替换（put/replace） |

**补充语义：**
- **所有 EXPIRED 都计入 eviction 统计，但事件类型仍为 EXPIRED。**
- eviction 统计包含：EXPIRED 与 SIZE/WEIGHT 驱逐。

---

## 7. 统计模型

- hits / misses / puts / removals / evictions。
- 过期命中视为 miss。
- invoke 内部操作不重复计数。
- clear 不计 eviction。

### 7.1 统计更新时机（并发 + 回滚风险控制）

**强制规则：**
- miss 在**确认不存在/已过期**时立即计数，与 load 是否成功无关。
- 统计仅在**最终状态确认后**累加（避免回滚与异常导致统计漂移）。
- 所有异常路径走**单独计数器**（如 loadFailure / writeFailure），避免混入 hit/miss/put。
- 对 read-through：load 成功并写入后才计 put；load 失败仅计 loadFailure。
- 对 write-through：writer 成功后才计 put/removal；writer 失败仅计 writeFailure。
- clear 计 removal，不计 eviction。

### 7.2 统计边界情况（必须明确）

- getAndRemove：key 不存在时不计任何统计。
- replace：key 不存在时不计任何统计。
- putIfAbsent：key 已存在时计 hit，不计 put；key 不存在时计 put（并计 miss）。
- iterator：不计 hit/miss（仅用于遍历视图）。

### 7.3 异常计数器定义表

| 计数器 | 触发条件 | 统计归属 |
| --- | --- | --- |
| loadFailure | read-through 调用 loader 抛异常 | 独立异常统计，不计 hit/miss/put |
| writeFailure | write-through 调用 writer 抛异常 | 独立异常统计，不计 put/removal |
| loadDiscarded | load 成功但写入前发现已被并发更新而丢弃 | 独立监控统计，不计 put |

### 7.4 异常计数器与统计归属细化

**read-through（get/getAll/invoke read-through）**
- miss：在确认不存在/过期时立即计数（无论 load 成功与否）。
- loadFailure：loader 抛异常计数；不计 put。
- loadDiscarded：load 成功但被并发更新丢弃；不计 put。
- load 成功写入：计 put；并触发 CREATED 事件。

**write-through（put/putAll/remove/removeAll/clear）**
- writeFailure：writer 抛异常计数；不计 put/removal；不触发事件。
- writer 成功：计 put 或 removal；触发对应事件。

**EntryProcessor（invoke/invokeAll）**
- processor 异常：抛 `EntryProcessorException`；不回滚已提交变更；已提交变更按正常统计归属。
- 若触发 read-through：遵循 read-through 统计归属规则。

**统计归属原则（统一）**
- 异常计数器与主统计互斥：一旦触发异常计数器，不得同时计入 put/removal。
- hit/miss 与 put/removal 可同时存在（如 getAndPut 命中后写入）。
- clear 仅计 removal，不计 eviction。

---

## 8. Read-through / Write-through

### 8.1 Read-through（CacheLoader）
- miss 或过期触发 load。
- 返回 null 不写入。
- 异常 → `CacheLoaderException`。
- **并发约束**：load 在 compute 之外执行，但写入前必须再次校验当前值，若已被其他线程更新，则丢弃 load 结果不覆盖新值。

**丢弃语义：**
- 若发现已被其他线程更新：
  - 返回当前缓存中的新值（非 load 结果）。
  - miss 计数保持不变（已计）。
  - 不计 put（因为未写入）。
  - 可选记录 loadDiscarded 计数用于监控。

### 8.2 Write-through（CacheWriter）
- 写外部先于写本地。
- 异常统一抛 `CacheWriterException`。
- 必须提供失败明细（key + 原因）。
- 批量写：成功 key 写入缓存，失败 key 不写入，最终统一抛异常并附带失败明细。

### 8.3 Read-through / Write-through 副作用顺序（强制约束）

为避免“缓存已写入但 writer 失败”等不一致，**读**与**写**分开定义固定顺序：

**GET（read-through）顺序：** `load (if miss)` → `cache put (原子)` → `event` → `stats` → `return`

**PUT/REMOVE（write-through）顺序：** `write-through` → `cache put/remove (原子)` → `event` → `stats` → `return`

**失败语义（write-through）：**
- writer 失败：**不写入 cache**，抛 `CacheWriterException` 并返回失败明细。
- event 仅对**最终成功状态**触发（writer 失败不发事件）。
- stats 记录的成功/失败遵循上面顺序：writer 失败视为失败，不计成功事件。

### 8.4 异常设计（补充）

- `CacheLoaderException`：read-through 失败时抛出，不写入缓存。
- `CacheWriterException`：write-through 失败时抛出，缓存不更新，并提供失败明细。
- `EntryProcessorException`：processor 运行异常，缓存状态以已提交变更为准（不得回滚已提交）。
- `CacheException`：reentrant 调用或违反约束时抛出。
- `NullPointerException`：key/value 为 null 时抛出（与 JCache 约定一致）。

---

## 9. 批量操作语义

- 批量整体不要求原子。
- 单 key 仍用 `asMap` 原子。
- 尽量使用批量 API（如 `getAllPresent`）提高性能。
- **语义等价于 N 次单 key 操作**：
  - listener 逐 key 触发（不得合并为单次事件）。
  - stats 逐 key 计数（不得合并为单次计数）。
  - write-through / read-through 逐 key 调用（可批量优化但语义逐 key）。

### 9.1 批量 API 与逐 key 语义一致的实现约束清单

**必须满足的约束：**
1. **逐 key 原子性**：每个 key 的读改写逻辑必须使用 `asMap` 原子操作完成。
2. **逐 key 事件**：无论是否批量优化，事件必须逐 key 触发，不允许合并成单条事件。
3. **逐 key 统计**：hits/misses/puts/removals/evictions 必须逐 key 计数。
4. **逐 key 过期**：过期判断与清理必须逐 key 执行，且过期计入 eviction。
5. **逐 key read-through/write-through**：
  - 可批量调用 loader/writer，但对外语义必须等价于逐 key 调用。
  - 批量失败时必须保留失败明细，且对成功 key 生效、失败 key 不生效。
6. **顺序一致**：批量操作内部处理顺序不强制，但单 key 处理流程必须遵循对应场景的副作用顺序：
  - read-through：load → cache put → event → stats → return
  - write-through：writer → cache put/remove → event → stats → return
7. **部分成功可见性**：批量操作允许部分 key 成功、部分失败；不得为整体失败回滚已成功的 key。
8. **禁止共享临时状态**：批量流程中不得共享可变中间态，避免跨 key 干扰。

---

## 9.2 API 级副作用顺序矩阵（强制遵循）

> 说明：仅列出语义路径，真实实现需保持“副作用不在 compute 内”。

### 9.2.1 Read-path 顺序矩阵

| API | 顺序（成功路径） | 异常路径与处理 |
| --- | --- | --- |
| get (miss+read-through) | load → cache put → event(CREATED) → stats | load 失败 → 抛 `CacheLoaderException`，计 loadFailure |
| get (hit/expired) | （hit）event? 否 → stats(hit) /（expired）event(EXPIRED) → stats(miss) | expired 清理计 eviction |
| getAll | per-key：同 get | per-key：同 get；失败不影响其他 key |
| containsKey | 仅过期校验 →（expired）event(EXPIRED) | 不计 hit/miss |
| iterator | 遍历视图，遇过期：触发 EXPIRED + eviction | 不计 hit/miss |

### 9.2.2 Write-path 顺序矩阵

| API | 顺序（成功路径） | 异常路径与处理 |
| --- | --- | --- |
| put | writer → cache put → event(CREATED/UPDATED) → stats(put) | writer 失败 → 抛 `CacheWriterException`，计 writeFailure |
| putIfAbsent | writer → cache put → event(CREATED) → stats(put) | 已存在：stats(hit)；writer 失败同 put |
| getAndPut | writer → cache put → event(CREATED/UPDATED) → stats(hit/put) | writer 失败同 put |
| replace | writer → cache put → event(UPDATED) → stats(hit/put) | 不存在：不计统计；writer 失败同 put |
| remove | writer → cache remove → event(REMOVED) → stats(removal) | writer 失败 → 抛 `CacheWriterException`，计 writeFailure |
| getAndRemove | writer → cache remove → event(REMOVED) → stats(hit/removal) | 不存在：不计统计；writer 失败同 remove |
| removeAll(Set) | per-key：同 remove | per-key：同 remove；失败不影响其他 key |
| clear | writer → cache clear → stats(removal) | writer 失败 → 抛 `CacheWriterException`，计 writeFailure；不触发逐条事件 |

### 9.2.3 Invoke-path 顺序矩阵

| API | 顺序（成功路径） | 异常路径与处理 |
| --- | --- | --- |
| invoke | 两阶段：compute标记 → load(可选) → compute执行 → event/stats | load 失败 → `CacheLoaderException`；processor 异常 → `EntryProcessorException` |
| invokeAll | per-key：同 invoke | per-key：同 invoke；失败不影响其他 key |

---

## 10. 通用策略定义（统一语义抽象）

- ExpirationPolicy：创建/访问/更新过期规则。
- ReadThroughPolicy：加载策略、异常映射、批量加载策略。
- WriteThroughPolicy：外部写入顺序、失败策略、失败明细格式。
- BatchPolicy：批量 API 优化策略、并发度控制。
- EventPolicy：事件同步/异步、顺序保证。
- StatsPolicy：计数口径与耗时统计。

---

## 11. 配置模型（YmsConfiguration）

`YmsConfiguration extends MutableConfiguration`，新增：
- `maximumSize`（可选）
- `maximumWeight`（可选）
- `weigher`（必配）

约束：
- `maximumSize` 与 `maximumWeight` 互斥。
- 未配置 `weigher` 不允许设置 `maximumWeight`。

---

## 12. API 覆盖矩阵

| API | 单 key 原子 | 过期更新 | 事件 | 统计 | read-through | write-through |
| --- | --- | --- | --- | --- | --- | --- |
| get | 是 | access | EXPIRED(过期) / CREATED(load成功) | hit/miss | 是 | 否 |
| getAll | 每 key 原子 | access | EXPIRED(过期) / CREATED(load成功) | hit/miss | 是 | 否 |
| put | 是 | create/update | CREATED/UPDATED | put | 否 | 是 |
| putAll | 每 key 原子 | create/update | CREATED/UPDATED | put | 否 | 是 |
| putIfAbsent | 是 | create | CREATED | put/miss | 否 | 是 |
| getAndPut | 是 | update | CREATED/UPDATED | hit/put | 否 | 是 |
| getAndRemove | 是 | n/a | REMOVED | hit/removal | 否 | 是 |
| replace | 是 | update | UPDATED | hit/put | 否 | 是 |
| replace(k,old,new) | 是 | update | UPDATED | hit/put | 否 | 是 |
| remove | 是 | n/a | REMOVED | removal | 否 | 是 |
| remove(k,v) | 是 | n/a | REMOVED | removal | 否 | 是 |
| removeAll | 每 key 原子 | n/a | REMOVED | removal | 否 | 是 |
| clear | 否 | n/a | 不触发 | removal | 否 | 是 |
| containsKey | 是 | access | EXPIRED(过期) | 不计 | 否 | 否 |
| iterator | 每 key 原子 | access | EXPIRED(过期) | 不计 | 否 | 否 |
| invoke | 是 | create/update/access | CREATED/UPDATED/REMOVED/EXPIRED | put/removal/hit/miss | 是（两阶段） | 视操作 |
| invokeAll | 每 key 原子 | create/update/access | 同 invoke | 同 invoke | 是（两阶段） | 视操作 |
| close/isClosed | n/a | n/a | n/a | n/a | n/a | n/a |
| getConfiguration | n/a | n/a | n/a | n/a | n/a | n/a |

**说明：**
- `clear` 执行 write-through 时不触发逐条事件；若业务依赖事件同步外部状态，应使用逐 key remove/removeAll。

---

## 13. 工程风险与验收要点

**风险**
- 惰性过期造成内存滞留。
- **原子边界不清导致副作用进入 compute，产生不可测时序与测试地狱。**
- write-through 批量失败处理可能引入额外性能开销。
- by-value 复制失败的异常传播策略需明确。

**验收要点**
- API 覆盖矩阵全部通过。
- 事件顺序、统计口径一致。
- 并发场景单 key 原子性验证。

---

## 14. TDD 开发流程（必须执行）

1. 先写测试后实现,必须提供先行测试与红/绿/重构证据
2. 以语义测试驱动设计与重构。
3. 所有 API、过期/事件/统计/read-write-through 必须有测试覆盖。

---

## 15. 质量与验收标准（补充）

- **测试驱动开发（TDD）**：所有功能先测后写。
- **覆盖率要求**：**语句/分支/方法覆盖率 100%**（以 CI 报告为准）。
- 关键语义（原子边界、read/write-through 顺序、事件/统计口径）需有专门用例覆盖。

